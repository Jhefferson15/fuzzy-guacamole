<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Editor de Fluxo Visual Interativo</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #fff;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        .question-card {
            background-color: #f0f4f8;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
            width: 90%;
            max-width: 1000px;
            text-align: center;
        }

        .question-card h2 {
            margin-top: 0;
            color: #2da9a4;
        }
        .question-card p {
            margin-bottom: 5px;
        }
        .question-card .source-ref {
            font-size: 0.85em;
            color: #777;
            margin-top: 10px;
            font-style: italic;
        }

        #flow-editor-container {
            position: relative;
            width: 90%;
            max-width: 1000px;
            display: flex;
            justify-content: space-between;
            padding: 20px 0;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .column {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        #left-column {
            width: 35%;
        }

        #right-column {
            width: 50%;
        }

        .node {
            background-color: #e9ecef;
            border: 2px solid #d0d0d0;
            border-radius: 10px;
            padding: 12px 18px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            position: relative;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            user-select: none;
            z-index: 2;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            word-wrap: break-word;
        }
        #left-column .node {
            max-width: 280px; /* Mantém a largura uniforme para a coluna 1 */
            /* height: auto; /* Altura não uniforme para a coluna 1 */
        }
        /* #right-column .node {
            height: auto; /* Altura não uniforme para a coluna 2, se necessário, caso contrário pode remover
        } */


        .node.drawing-from {
            box-shadow: 0 0 0 3px #2da9a4, 0 4px 8px rgba(0,0,0,0.2);
        }
        .node-text {
            margin-bottom: 5px;
        }
        .distractor-explanation {
            font-size: 0.85em;
            color: #c0392b;
            margin-top: 10px;
            text-align: left;
            border-top: 1px solid #ddd;
            padding-top: 10px;
            width: 100%;
            box-sizing: border-box;
            background-color: #fdf6f6;
            padding: 10px;
            border-radius: 0 0 8px 8px;
            display: none;
        }

        .correct-answer-hint {
            font-size: 0.8em;
            color: #27ae60;
            margin-top: 10px;
            text-align: left;
            border-top: 1px solid #ddd;
            padding-top: 8px;
            width: 100%;
            box-sizing: border-box;
            background-color: #f6fdf6;
            padding: 8px 10px;
            border-radius: 0 0 8px 8px;
            display: none;
            font-style: italic;
        }


        .port {
            width: 10px;
            height: 10px;
            background-color: #bbb;
            border: 1px solid #fff;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            box-shadow: 0 0 2px rgba(0,0,0,0.1);
            z-index: 5;
        }

        .output-port { right: -6px; }
        .input-port { left: -6px; }

        #left-column .node .input-port { display: none; }
        #right-column .node .output-port { display: none; }


        .connection-marker {
            position: absolute;
            width: 24px;
            height: 24px;
            color: white;
            background-color: #2da9a4;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            font-weight: bold;
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            border: 1px solid rgba(0,0,0,0.1);
        }

        .output-marker { right: -12px; }
        .input-marker { left: -12px; }
        .connection-marker span { line-height: 1; }


        #connections-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .connection-line {
            stroke-width: 3.5px;
            fill: none;
            stroke: #2da9a4;
        }
        .connection-line-animated {
            animation: dashdraw 0.7s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
        }

        @keyframes dashdraw {
            to {
                stroke-dashoffset: 0;
            }
        }

        .connection-haste {
            position: absolute;
            height: 3.5px;
            background: #2da9a4;
            z-index: 0;
            pointer-events: none;
            border-radius: 1.75px;
        }

        .bottom-controls-container {
            width: 90%;
            max-width: 1000px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-top: 20px;
            padding: 15px;
            background-color: #f0f4f8;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .navigation-buttons {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .bottom-controls-container button {
            padding: 12px 25px;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 500;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .bottom-controls-container button:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.15);
        }
        .bottom-controls-container button:active:not(:disabled) {
            transform: translateY(0px);
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .bottom-controls-container button:disabled {
            background-color: #bdc3c7 !important;
            cursor: not-allowed;
            box-shadow: none;
        }

        #prev-flashcard-btn, #next-flashcard-btn {
            background-color: #3498db;
            min-width: 120px;
        }
        #prev-flashcard-btn:hover:not(:disabled), #next-flashcard-btn:hover:not(:disabled) {
            background-color: #2980b9;
        }

    </style>
</head>
<body>

    <div class="question-card">
        <h2 id="card-title">Carregando...</h2>
        <p id="card-description">Conecte os conceitos da esquerda com suas correspondências à direita.</p>
        <p id="card-source-ref" class="source-ref"></p>
    </div>

    <div id="flow-editor-container">
        <div id="left-column" class="column"></div>
        <div id="right-column" class="column"></div>
        <svg id="connections-svg"></svg>
    </div>

    <div class="bottom-controls-container">
        <div class="navigation-buttons">
            <button id="prev-flashcard-btn" title="Flashcard Anterior" disabled>&lt; Anterior</button>
            <button id="next-flashcard-btn" title="Próximo Flashcard" disabled>&gt; Próximo</button>
        </div>
    </div>

    <script>
        const leftColumn = document.getElementById('left-column');
        const rightColumn = document.getElementById('right-column');
        const svgCanvas = document.getElementById('connections-svg');
        const editorContainer = document.getElementById('flow-editor-container');

        const prevFlashcardBtn = document.getElementById('prev-flashcard-btn');
        const nextFlashcardBtn = document.getElementById('next-flashcard-btn');

        const cardTitleEl = document.getElementById('card-title');
        const cardDescriptionEl = document.getElementById('card-description');
        const cardSourceRefEl = document.getElementById('card-source-ref');

        let nodes = {};
        let connections = [];
        let isDrawing = false;
        let startNodeId = null;
        let startPortElement = null;
        let tempLine = null;

        let nodeIdCounter = 0;
        let globalConnectionIdCounter = 0;
        const HASTE_HEIGHT = 3.5;
        let allowMultipleConnections = false;
        let answersHaveBeenChecked = false;

        let bookData = null;
        let currentModuleIndex = 0;
        let currentFlashcardIndex = 0;
        let currentFlashcardData = {
            gabarito: [],
            leftNodesFullOriginal: [],
            rightNodesFullOriginal: [],
            shuffledRightNodesForDisplayIndexing: []
        };

        const GITHUB_CONFIG_URL = 'https://raw.githubusercontent.com/Jhefferson15/fuzzy-guacamole/main/Portugu%C3%AAs%20-%20Livro%201%20-%20Frente%20A.json';

        async function fetchConfig(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    console.warn(`Erro ao buscar config de ${url}: ${response.status} ${response.statusText}`);
                    cardTitleEl.textContent = "Erro de Rede";
                    cardDescriptionEl.textContent = `Não foi possível carregar os dados. Status: ${response.status}`;
                    return null;
                }
                const configData = await response.json();
                return configData;
            } catch (error) {
                console.error("Falha ao buscar ou parsear JSON de configuração:", error);
                cardTitleEl.textContent = "Erro ao Processar Dados";
                cardDescriptionEl.textContent = "Falha ao processar o arquivo de configuração.";
                return null;
            }
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function loadFlashcard(moduleIdx, flashcardIdx) {
            if (!bookData || !bookData.modules || !bookData.modules[moduleIdx] || !bookData.modules[moduleIdx].flashcards[flashcardIdx]) {
                console.error("Flashcard não encontrado:", moduleIdx, flashcardIdx);
                cardTitleEl.textContent = "Erro ao carregar flashcard";
                cardDescriptionEl.textContent = "Verifique os dados ou a seleção.";
                return;
            }

            currentModuleIndex = moduleIdx;
            currentFlashcardIndex = flashcardIdx;
            const module = bookData.modules[moduleIdx];
            const flashcard = module.flashcards[flashcardIdx];

            cardTitleEl.textContent = `${module.moduleTitle} - Atividade ${flashcard.id}`;
            cardDescriptionEl.textContent = `Conecte os itens da esquerda com os da direita.`;
            cardSourceRefEl.textContent = `Fonte: ${module.sourceReference || 'Não especificada'}`;

            resetAllConnections();

            leftColumn.innerHTML = '';
            rightColumn.innerHTML = '';
            nodes = {};
            nodeIdCounter = 0;

            currentFlashcardData.gabarito = flashcard.gabarito;
            currentFlashcardData.leftNodesFullOriginal = flashcard.leftColumnNodes.map((text, index) => ({
                text,
                originalIndex: index
            }));
            const shuffledLeftNodes = shuffleArray([...currentFlashcardData.leftNodesFullOriginal]);

            currentFlashcardData.rightNodesFullOriginal = flashcard.rightColumnNodes.map((nodeData, index) => ({
                ...nodeData,
                originalIndex: index
            }));
            currentFlashcardData.shuffledRightNodesForDisplayIndexing = shuffleArray([...currentFlashcardData.rightNodesFullOriginal]);


            shuffledLeftNodes.forEach(nodeData => {
                addNode(nodeData.text, 'left', nodeData.originalIndex);
            });

            currentFlashcardData.shuffledRightNodesForDisplayIndexing.forEach(nodeDataWithOriginalIndex => {
                addNode(nodeDataWithOriginalIndex.text, 'right', nodeDataWithOriginalIndex.originalIndex, nodeDataWithOriginalIndex.isDistractor, nodeDataWithOriginalIndex.distractorExplanation);
            });

            updateNavigationButtons();
            setTimeout(redrawAllConnections, 50);
        }


        async function initializeApp() {
            bookData = await fetchConfig(GITHUB_CONFIG_URL);
            if (bookData && bookData.modules && bookData.modules.length > 0) {
                loadFlashcard(0, 0);
            } else {
                prevFlashcardBtn.disabled = true;
                nextFlashcardBtn.disabled = true;
            }
        }

        function updateNavigationButtons() {
            if (!bookData || !bookData.modules || bookData.modules.length === 0) {
                prevFlashcardBtn.disabled = true;
                nextFlashcardBtn.disabled = true;
                return;
            }
            const currentModule = bookData.modules[currentModuleIndex];
            prevFlashcardBtn.disabled = (currentModuleIndex === 0 && currentFlashcardIndex === 0);
            nextFlashcardBtn.disabled = (currentModuleIndex === bookData.modules.length - 1 &&
                                       currentFlashcardIndex === currentModule.flashcards.length - 1);
        }

        prevFlashcardBtn.addEventListener('click', () => {
            if (currentFlashcardIndex > 0) {
                loadFlashcard(currentModuleIndex, currentFlashcardIndex - 1);
            } else if (currentModuleIndex > 0) {
                const prevModuleIndex = currentModuleIndex - 1;
                const prevModule = bookData.modules[prevModuleIndex];
                loadFlashcard(prevModuleIndex, prevModule.flashcards.length - 1);
            }
        });

        nextFlashcardBtn.addEventListener('click', () => {
            const currentModule = bookData.modules[currentModuleIndex];
            if (currentFlashcardIndex < currentModule.flashcards.length - 1) {
                loadFlashcard(currentModuleIndex, currentFlashcardIndex + 1);
            } else if (currentModuleIndex < bookData.modules.length - 1) {
                loadFlashcard(currentModuleIndex + 1, 0);
            }
        });


        function createNodeElement(id, text, originalIndex, columnType, isDistractor, distractorExplanationText) {
            const nodeEl = document.createElement('div');
            nodeEl.classList.add('node');
            nodeEl.dataset.nodeId = id;
            nodeEl.dataset.originalIndex = originalIndex;
            nodeEl.dataset.columnType = columnType;

            const textSpan = document.createElement('span');
            textSpan.classList.add('node-text');
            textSpan.textContent = text;
            nodeEl.appendChild(textSpan);

            if (columnType === 'right') {
                nodeEl.dataset.isDistractor = !!isDistractor;
                nodeEl.dataset.distractorExplanation = distractorExplanationText || "";

                const explanationDiv = document.createElement('div');
                explanationDiv.classList.add('distractor-explanation');
                nodeEl.appendChild(explanationDiv);
            } else if (columnType === 'left') {
                const hintDiv = document.createElement('div');
                hintDiv.classList.add('correct-answer-hint');
                nodeEl.appendChild(hintDiv);
            }

            const outputPort = document.createElement('div');
            outputPort.classList.add('port', 'output-port');
            nodeEl.appendChild(outputPort);

            const inputPort = document.createElement('div');
            inputPort.classList.add('port', 'input-port');
            nodeEl.appendChild(inputPort);

            nodeEl.addEventListener('click', handleNodeClick);
            return nodeEl;
        }

        function addNode(text, columnType, originalIndex, isDistractor = false, distractorExplanationText = "") {
            const id = `node-${nodeIdCounter++}`;
            const nodeEl = createNodeElement(id, text, originalIndex, columnType, isDistractor, distractorExplanationText);
            if (columnType === 'left') {
                leftColumn.appendChild(nodeEl);
            } else {
                rightColumn.appendChild(nodeEl);
            }
            nodes[id] = {
                id: id,
                element: nodeEl,
                text: text,
                originalIndex: originalIndex,
                columnType: columnType,
                isDistractor: !!isDistractor,
                distractorExplanation: distractorExplanationText
            };
            return id;
        }

        function getPortPosition(portElement) {
            const editorRect = editorContainer.getBoundingClientRect();
            const nodeElement = portElement.closest('.node');
            const nodeRect = nodeElement.getBoundingClientRect();
            let yPositionInNode = nodeElement.offsetHeight / 2;

            return {
                x: (portElement.classList.contains('output-port') ? nodeRect.right : nodeRect.left) - editorRect.left,
                y: nodeRect.top - editorRect.top + yPositionInNode
            };
        }


        function createBezierPath(p1, p2) {
            const dx_abs = Math.abs(p2.x - p1.x);
            let offset = dx_abs * 0.4;
            if (p1.y === p2.y) return `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
            if (dx_abs < 50) offset = dx_abs * 0.6;
            if (dx_abs < 10 && dx_abs !== 0) offset = 5;
            if (dx_abs === 0) offset = 0;

            let cp1x = p1.x + (p2.x > p1.x ? offset : -offset);
            let cp2x = p2.x - (p2.x > p1.x ? offset : -offset);
            return `M ${p1.x} ${p1.y} C ${cp1x} ${p1.y}, ${cp2x} ${p2.y}, ${p2.x} ${p2.y}`;
        }

        function drawLine(p1, p2, existingPath = null, isFinalizing = false) {
            const pathData = createBezierPath(p1, p2);
            let line = existingPath;
            if (!line) {
                line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                line.classList.add('connection-line');
                svgCanvas.appendChild(line);
            }
            line.setAttribute('d', pathData);
            if (isFinalizing && line && !line.dataset.animationCompleted) {
                line.dataset.animationCompleted = "true";
                const length = (p1.y === p2.y && Math.abs(p1.x - p2.x) > 0) ? Math.abs(p1.x - p2.x) : (line.getTotalLength ? line.getTotalLength() : 0);
                if (length > 1) {
                    line.style.strokeDasharray = length;
                    line.style.strokeDashoffset = length;
                    line.getBoundingClientRect();
                    line.classList.add('connection-line-animated');
                    line.addEventListener('animationend', function handleAnimationEnd() {
                        line.style.strokeDasharray = 'none'; line.style.strokeDashoffset = '0';
                        line.classList.remove('connection-line-animated');
                        line.removeEventListener('animationend', handleAnimationEnd);
                    }, { once: true });
                } else {
                     line.style.strokeDasharray = 'none'; line.style.strokeDashoffset = '0';
                }
            }
            return line;
        }

        function createMarkerElement(visualMarkerType) {
            const marker = document.createElement('div');
            marker.classList.add('connection-marker', visualMarkerType === 'output' ? 'output-marker' : 'input-marker');
            const span = document.createElement('span');
            marker.appendChild(span);
            return marker;
        }

        function appendAndPositionMarker(nodeElement, newMarker, markerType) {
            nodeElement.appendChild(newMarker);
        }

        function repositionMarkersOnNode(nodeElement, markerType) {
            const markerSelector = markerType === 'output' ? '.output-marker' : '.input-marker';
            const existingMarkers = Array.from(nodeElement.querySelectorAll(markerSelector));
            if (existingMarkers.length === 0) return;

            existingMarkers.sort((a, b) => parseInt(a.dataset.connectionNumber) - parseInt(b.dataset.connectionNumber));

            const nodeCenterY = nodeElement.offsetHeight / 2;
            const markerHeight = existingMarkers[0].offsetHeight;
            const spacing = 4;
            const totalMarkersHeight = existingMarkers.length * markerHeight + Math.max(0, existingMarkers.length - 1) * spacing;

            let startYGroup = nodeCenterY - totalMarkersHeight / 2;
            const paddingTop = 5;
            const paddingBottom = 5;

            startYGroup = Math.max(paddingTop, startYGroup);
            if (startYGroup + totalMarkersHeight > nodeElement.offsetHeight - paddingBottom) {
                startYGroup = Math.max(paddingTop, nodeElement.offsetHeight - paddingBottom - totalMarkersHeight);
            }

            existingMarkers.forEach((marker, index) => {
                const targetCenterYOfThisMarker = startYGroup + index * (markerHeight + spacing) + (markerHeight / 2);
                const yOffsetFromNodeCenter = targetCenterYOfThisMarker - nodeCenterY;
                marker.style.transform = `translateY(calc(-50% + ${yOffsetFromNodeCenter}px))`;
            });
        }

        function removeConnection(connectionToRemove, skipUpdatingNumbers = false) {
            if (!connectionToRemove) return;
            if (connectionToRemove.line) connectionToRemove.line.remove();
            if (connectionToRemove.haste) connectionToRemove.haste.remove();
            if (connectionToRemove.markers) connectionToRemove.markers.forEach(marker => marker.remove());

            if (!answersHaveBeenChecked) {
                 if (nodes[connectionToRemove.from] && nodes[connectionToRemove.from].element) {
                    nodes[connectionToRemove.from].element.style.borderColor = '';
                    const hintDiv = nodes[connectionToRemove.from].element.querySelector('.correct-answer-hint');
                    if (hintDiv) hintDiv.style.display = 'none';
                }
                if (nodes[connectionToRemove.to] && nodes[connectionToRemove.to].element) {
                    nodes[connectionToRemove.to].element.style.borderColor = '';
                    const explDiv = nodes[connectionToRemove.to].element.querySelector('.distractor-explanation');
                    if (explDiv) explDiv.style.display = 'none';
                }
            }

            const index = connections.indexOf(connectionToRemove);
            if (index > -1) connections.splice(index, 1);

            if (!skipUpdatingNumbers) {
                 updateDisplayedConnectionNumbersAndMarkers();
                 checkAndHandleVerificationState();
            }
        }

        function updateDisplayedConnectionNumbersAndMarkers() {
            connections.sort((a, b) => a.id - b.id);
            const affectedNodes = new Set();

            connections.forEach((conn, index) => {
                const displayedNumber = index + 1;
                conn.markers[0].querySelector('span').textContent = displayedNumber;
                conn.markers[1].querySelector('span').textContent = displayedNumber;
                conn.markers[0].dataset.connectionNumber = displayedNumber;
                conn.markers[1].dataset.connectionNumber = displayedNumber;
                affectedNodes.add(conn.from);
                affectedNodes.add(conn.to);
            });

            affectedNodes.forEach(nodeId => {
                const nodeData = nodes[nodeId];
                if (nodeData && nodeData.element) {
                    repositionMarkersOnNode(nodeData.element, nodeData.columnType === 'left' ? 'output' : 'input');
                }
            });

            if (connections.length === 0) {
                Object.values(nodes).forEach(nodeData => {
                    if (nodeData.element) {
                        Array.from(nodeData.element.querySelectorAll('.connection-marker')).forEach(m => m.remove());
                    }
                });
            }
        }

        function resetVisualFeedback(forceClear = false) {
            if (answersHaveBeenChecked && !forceClear) {
                return;
            }

            Object.values(nodes).forEach(nodeData => {
                if (nodeData.element) {
                    nodeData.element.style.borderColor = '';
                    if (nodeData.columnType === 'right') {
                        const explDiv = nodeData.element.querySelector('.distractor-explanation');
                        if (explDiv) {
                            explDiv.style.display = 'none';
                            explDiv.textContent = '';
                        }
                    } else if (nodeData.columnType === 'left') {
                        const hintDiv = nodeData.element.querySelector('.correct-answer-hint');
                        if (hintDiv) {
                            hintDiv.style.display = 'none';
                            hintDiv.textContent = '';
                        }
                    }
                }
            });
        }

        function resetAllConnections() {
            [...connections].forEach(conn => removeConnection(conn, true));
            connections = [];
            globalConnectionIdCounter = 0;
            
            answersHaveBeenChecked = false;
            resetVisualFeedback(true);
            
            updateDisplayedConnectionNumbersAndMarkers();
            setTimeout(redrawAllConnections, 0);
        }

        function checkAndHandleVerificationState() {
            const leftNodeElements = Array.from(leftColumn.querySelectorAll('.node'));
            if (leftNodeElements.length === 0) {
                 if (answersHaveBeenChecked) { // if no nodes, but feedback was on, clear it
                    resetVisualFeedback(true);
                    answersHaveBeenChecked = false;
                }
                return;
            }

            const allLeftConnected = leftNodeElements.every(leftNodeEl => {
                return connections.some(conn => conn.from === leftNodeEl.dataset.nodeId);
            });

            if (allLeftConnected) {
                performVerificationAndFeedback();
                answersHaveBeenChecked = true;
            } else {
                resetVisualFeedback(); // Will do nothing if answersHaveBeenChecked is true and no forceClear
            }
        }


        function handleNodeClick(event) {
            event.stopPropagation();

            const clickedNodeElement = event.currentTarget;
            const nodeId = clickedNodeElement.dataset.nodeId;
            const nodeData = nodes[nodeId];
            if (!nodeData) return;

            if (!isDrawing) {
                // REMOVED: The block that would resetVisualFeedback(true) if answersHaveBeenChecked was true.
                // This ensures feedback persists if the user starts a new connection after feedback was shown.

                isDrawing = true;
                startNodeId = nodeId;
                startPortElement = clickedNodeElement.querySelector(nodeData.columnType === 'left' ? '.output-port' : '.input-port');
                if (!startPortElement) { resetDrawingState(); return; }
                nodes[startNodeId].element.classList.add('drawing-from');
                const startPos = getPortPosition(startPortElement);
                tempLine = drawLine(startPos, startPos);
                document.addEventListener('mousemove', handlePointerMove);
                document.addEventListener('touchmove', handlePointerMove, { passive: false });
                document.addEventListener('mouseup', handlePointerUp, { once: true });
                document.addEventListener('touchend', handlePointerUp, { once: true });
                document.addEventListener('touchcancel', handlePointerUp, { once: true });
            } else {
                const startNodeData = nodes[startNodeId];
                if (startNodeData.element) startNodeData.element.classList.remove('drawing-from');

                if (startNodeId && startNodeData && nodeData.columnType !== startNodeData.columnType && startNodeId !== nodeId) {
                    let finalFromNodeId = startNodeData.columnType === 'left' ? startNodeId : nodeId;
                    let finalToNodeId = startNodeData.columnType === 'left' ? nodeId : startNodeId;
                    let finalFromPortEl = nodes[finalFromNodeId].element.querySelector('.output-port');
                    let finalToPortEl = nodes[finalToNodeId].element.querySelector('.input-port');

                    if (!finalFromPortEl || !finalToPortEl) {
                        if (tempLine) tempLine.remove(); tempLine = null;
                        resetDrawingState(); return;
                    }

                    if (!allowMultipleConnections) {
                        const connectionsToRemove = new Set();
                        connections.forEach(conn => {
                            if (conn.from === finalFromNodeId) connectionsToRemove.add(conn);
                            if (conn.to === finalToNodeId) connectionsToRemove.add(conn);
                        });
                        connectionsToRemove.forEach(conn => removeConnection(conn, true));
                    }

                    const existingExactConnection = connections.find(c => c.from === finalFromNodeId && c.to === finalToNodeId);
                    if (existingExactConnection) {
                        if (tempLine) tempLine.remove(); tempLine = null;
                        resetDrawingState();
                        return;
                    }

                    const p1 = getPortPosition(finalFromPortEl);
                    const p2 = getPortPosition(finalToPortEl);
                    const finalSvgLine = drawLine(p1, p2, tempLine, true);
                    tempLine = null;

                    let htmlHasteElement = null;
                    if (Math.abs(p1.y - p2.y) < 1.5) {
                        // ... haste logic ...
                    }

                    globalConnectionIdCounter++;
                    const outputMarker = createMarkerElement('output');
                    const inputMarker = createMarkerElement('input');
                    appendAndPositionMarker(nodes[finalFromNodeId].element, outputMarker, 'output');
                    appendAndPositionMarker(nodes[finalToNodeId].element, inputMarker, 'input');

                    connections.push({
                        id: globalConnectionIdCounter, from: finalFromNodeId, to: finalToNodeId,
                        line: finalSvgLine, haste: htmlHasteElement, markers: [outputMarker, inputMarker]
                    });

                    updateDisplayedConnectionNumbersAndMarkers();
                    checkAndHandleVerificationState();
                    resetDrawingState();
                } else {
                    if (tempLine) tempLine.remove(); tempLine = null;
                    resetDrawingState();
                }
            }
        }

        function handlePointerMove(event) {
            if (!isDrawing || !tempLine || !startPortElement) return;
            let clientX, clientY;
            if (event.type.startsWith('touch')) {
                if (event.touches && event.touches.length > 0) {
                    clientX = event.touches[0].clientX; clientY = event.touches[0].clientY;
                    event.preventDefault();
                } else return;
            } else {
                clientX = event.clientX; clientY = event.clientY;
            }

            const startNodeData = nodes[startNodeId];
            const startPos = getPortPosition(startPortElement);
            const editorRect = editorContainer.getBoundingClientRect();
            const pointerPos = {
                x: clientX - editorRect.left,
                y: clientY - editorRect.top
            };

            let p1_temp = startNodeData.columnType === 'left' ? startPos : pointerPos;
            let p2_temp = startNodeData.columnType === 'left' ? pointerPos : startPos;

            drawLine(p1_temp, p2_temp, tempLine, false);
        }

        function handlePointerUp(event) {
            document.removeEventListener('mousemove', handlePointerMove);
            document.removeEventListener('touchmove', handlePointerMove);
        }

        editorContainer.addEventListener('click', (event) => {
            if (isDrawing && (event.target === editorContainer || event.target === svgCanvas)) {
                if (tempLine) tempLine.remove(); tempLine = null;
                if (startNodeId && nodes[startNodeId] && nodes[startNodeId].element) {
                     nodes[startNodeId].element.classList.remove('drawing-from');
                }
                resetDrawingState();
            }
        });

        function resetDrawingState() {
            if (isDrawing && startNodeId && nodes[startNodeId] && nodes[startNodeId].element) {
                 nodes[startNodeId].element.classList.remove('drawing-from');
            }
            isDrawing = false; startNodeId = null; startPortElement = null;
            document.removeEventListener('mousemove', handlePointerMove);
            document.removeEventListener('touchmove', handlePointerMove);
            document.removeEventListener('mouseup', handlePointerUp);
            document.removeEventListener('touchend', handlePointerUp);
            document.removeEventListener('touchcancel', handlePointerUp);
        }

        function redrawAllConnections() {
            connections.forEach(conn => {
                const fromNodeData = nodes[conn.from], toNodeData = nodes[conn.to];
                if (!fromNodeData || !toNodeData) {
                    removeConnection(conn, true);
                    return;
                }

                const p1_port_el = fromNodeData.element.querySelector('.output-port');
                const p2_port_el = toNodeData.element.querySelector('.input-port');
                if (!p1_port_el || !p2_port_el) return;

                const p1 = getPortPosition(p1_port_el);
                const p2 = getPortPosition(p2_port_el);

                if (conn.line) conn.line.setAttribute('d', createBezierPath(p1, p2));

                if (conn.haste) {
                    if (Math.abs(p1.y - p2.y) < 1.5) {
                        conn.haste.style.top = `${p1.y - HASTE_HEIGHT / 2}px`;
                        const startX = Math.min(p1.x, p2.x);
                        const endX = Math.max(p1.x, p2.x);
                        const width = endX - startX;
                        if (width > 1) {
                            conn.haste.style.left = `${startX}px`;
                            conn.haste.style.width = `${width}px`;
                            conn.haste.style.display = '';
                        } else {
                            conn.haste.style.display = 'none';
                        }
                    } else {
                        conn.haste.remove();
                        conn.haste = null;
                    }
                }
            });
            updateDisplayedConnectionNumbersAndMarkers();
             setTimeout(() => {
                Object.values(nodes).forEach(nodeData => {
                    if (nodeData.element) {
                        repositionMarkersOnNode(nodeData.element, nodeData.columnType === 'left' ? 'output' : 'input');
                    }
                });
            }, 0);
        }

        function performVerificationAndFeedback() {
            const connectionCorrectness = new Map();
            const rightColumnNodesUI = Array.from(rightColumn.querySelectorAll('.node'));

            connections.forEach(conn => {
                const leftNodeOriginalIndex = parseInt(nodes[conn.from].element.dataset.originalIndex);
                const rightNodeOriginalIndex = parseInt(nodes[conn.to].element.dataset.originalIndex);

                const isCorrect = currentFlashcardData.gabarito.some(pair =>
                    pair.leftIndex === leftNodeOriginalIndex && pair.rightIndex === rightNodeOriginalIndex
                );
                connectionCorrectness.set(conn.id, isCorrect);
            });

            Object.values(nodes).forEach(nodeData => {
                const nodeEl = nodeData.element;
                const relevantConnections = connections.filter(c => c.from === nodeData.id || c.to === nodeData.id);

                if (relevantConnections.length > 0) {
                    const anyNodeConnectionIncorrect = relevantConnections.some(c => connectionCorrectness.get(c.id) === false);
                    const allNodeConnectionsCorrect = relevantConnections.every(c => connectionCorrectness.get(c.id) === true);

                    if (anyNodeConnectionIncorrect) {
                        nodeEl.style.borderColor = '#e74c3c';
                    } else if (allNodeConnectionsCorrect) {
                        nodeEl.style.borderColor = '#2da9a4';
                    } else {
                        nodeEl.style.borderColor = '';
                    }
                } else {
                    nodeEl.style.borderColor = '';
                }

                if (nodeData.columnType === 'left') {
                    const hintDiv = nodeEl.querySelector('.correct-answer-hint');
                    if (!hintDiv) return;

                    const leftNodeOriginalIndex = parseInt(nodeEl.dataset.originalIndex);
                    const connectionsFromThisNode = connections.filter(c => c.from === nodeData.id);
                    
                    let isAnyConnectionFromThisNodeIncorrect = false;
                    if (connectionsFromThisNode.length > 0) {
                         isAnyConnectionFromThisNodeIncorrect = connectionsFromThisNode.some(c => connectionCorrectness.get(c.id) === false);
                    }
                    
                    const isActuallyIncorrect = isAnyConnectionFromThisNodeIncorrect || 
                                                (currentFlashcardData.gabarito.some(g => g.leftIndex === leftNodeOriginalIndex) && connectionsFromThisNode.length === 0);


                    if (isActuallyIncorrect) {
                        const correctRightOriginalIndices = currentFlashcardData.gabarito
                            .filter(pair => pair.leftIndex === leftNodeOriginalIndex)
                            .map(pair => pair.rightIndex);
                        
                        if (correctRightOriginalIndices.length > 0) {
                            const correctRightDisplayIndicesText = correctRightOriginalIndices.map(rOriginalIndex => {
                                const targetRightNodeUI = rightColumnNodesUI.find(uiNodeEl => parseInt(uiNodeEl.dataset.originalIndex) === rOriginalIndex);
                                if (targetRightNodeUI) {
                                    return rightColumnNodesUI.indexOf(targetRightNodeUI) + 1;
                                }
                                return `?(${rOriginalIndex})`;
                            }).join(', ');

                            hintDiv.textContent = `Conexão correta com item da direita na posição: ${correctRightDisplayIndicesText}.`;
                            hintDiv.style.display = 'block';
                        } else {
                             hintDiv.style.display = 'none'; 
                        }
                    } else {
                        hintDiv.style.display = 'none';
                    }
                } else if (nodeData.columnType === 'right') {
                    const explanationDiv = nodeEl.querySelector('.distractor-explanation');
                    const originalRightNodeInfo = currentFlashcardData.rightNodesFullOriginal.find(
                        n => n.originalIndex === nodeData.originalIndex
                    );

                    if (explanationDiv && originalRightNodeInfo && originalRightNodeInfo.isDistractor) {
                        explanationDiv.textContent = originalRightNodeInfo.distractorExplanation || "Esta é uma opção distratora.";
                        explanationDiv.style.display = 'block';
                    } else if (explanationDiv) {
                        explanationDiv.style.display = 'none';
                    }
                }
            });
            setTimeout(redrawAllConnections, 50);
        }


        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(redrawAllConnections, 150);
        });

        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>
